#!/usr/bin/env python

import ast
import fcntl
import os
import sys

from gi.repository import GLib
from gi.repository import Gst

# for the moment...
gst_eval = ast.literal_eval

# init gstreamer, parse args
args = sys.argv[:]
Gst.init(args)

desc = ' '.join(args[1:])

# load gstreamer pipeline, press play

pipeline = Gst.parse_launch(desc)
pipeline.set_state(Gst.State.PLAYING)

def setup_non_blocking_read(f, on_line):
    fd = f.fileno()

    fl = fcntl.fcntl(fd, fcntl.F_GETFL)
    fcntl.fcntl(fd, fcntl.F_SETFL, fl | os.O_NONBLOCK)

    buf = ['']
    def on_data_available(fd, condition):
        data = f.read()
        buf[0] += data

        lines = buf[0].split('\n')
        buf[0] = lines.pop()

        for line in lines:
            on_line(line)

        return True

    GLib.io_add_watch(
        fd,
        GLib.IOCondition.IN,
        on_data_available,
    )

# make stdin non-blocking and handle lines

import re

def set_property(target, attr, value):
    el = pipeline.get_by_name(target)
    value = gst_eval(value)
    el.set_property(attr, value)

def link_pads(src, src_pad, char, dst, dst_pad):
    src_el = pipeline.get_by_name(src)
    dst_el = pipeline.get_by_name(dst)

    print src_el, src_pad, char, dst_el, dst_pad

    if char == '-':
        success = src_el.link_pads(src_pad, dst_el, dst_pad)
        if not success:
            print 'Could not link pads.'

    elif char == 'x':
        success = src_el.unlink_pads(src_pad, dst_el, dst_pad)
        if not success:
            print 'Could not unlink pads.'

def set_state(state):
    state = {
        'stop': Gst.State.READY,
        'play': Gst.State.PLAYING,
        'pause': Gst.State.PAUSED,
    }[state]
    pipeline.set_state(state)

def add_element(kind, properties):
    # TODO: write a proper parser, and don't have this here
    properties = dict(
        pair.split('=', 1)
        for pair in properties.split(' ')
    )

    # create the element
    name = properties.pop('name', None)
    element = Gst.ElementFactory.make(kind, name)

    # set the properties
    for key, value in properties:
        value = gst_eval(value)
        element.set_property(key, value)

    pipeline.add(element)

def remove_element(name):
    element = pipeline.get_by_name(name)
    pipeline.remove(element)

expressions = [
    ('^(\w+)\.(\w+) = (.+)$', set_property),
    ('^(\w+)(?:\.(\w+))? ([-x])> (\w+)(?:\.(\w+))?$', link_pads),
    ('^\+ (\w+)(?: (.*))?$', add_element),
    ('^- (\w+)$', remove_element),
    ('^(stop|play|pause)$', set_state),
]

# Compile all regexes
expressions = [
    (re.compile(regex), fn)
    for regex, fn in expressions
]

def on_line(line):
    for regex, fn in expressions:
        m = regex.match(line)
        if m:
            fn(*m.groups())
            break
    else:
        print 'Error: could not parse line.'

setup_non_blocking_read(sys.stdin, on_line)

# run glib main loop

loop = GLib.MainLoop()
loop.run()

